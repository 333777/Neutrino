package com.ebay.neutrino.balancer

import javax.annotation.Nullable

import com.ebay.neutrino._
import com.ebay.neutrino.config.{VirtualAddress, VirtualPool, CanonicalAddress}
import com.ebay.neutrino.metrics.Instrumented


/**
 * A customized PoolResolver supporting an efficient CNAME-based pool selection.
 *
 * This allows a pool to be selected using the request's host value, resolving
 * a matching pool from the pool's configured CNAME and port mapping.
 *
 * Previously, we assumed the NeutrinoPools provided covered the whole set of
 * pools and we were required to filter accordingly. Since V0.5.6 this behaviour
 * has changed so we no longer have to filter out non-matches. Now, we can
 * assume the NeutrinoPools provided is the full set of pools 'available' to
 * the resolver.
 *
 * In particular, the following changes have been made:
 *  - Previously:  matched by hostname, port, protocol
 *  - Currently:   match by hostname (NeutrinoPools has been filtered by port and protocol)
 **
 * TODO make data-structure more efficient for lookups
 * TODO fix parse order/data-structure
 * TODO add config as ctor-parameter
 */
class CNameResolver extends CachingResolver[String] with Instrumented {

  import scala.collection.JavaConversions._


  // Our UUID for matching
  object HostKey {
    def apply(address: CanonicalAddress): String = address.host.toLowerCase
    def apply(request: NeutrinoRequest): Option[String] = request.host map (h => h.host.toLowerCase)
  }

  // Our loader version; is incremented on every update
  private[balancer] var ports = Seq.empty[Int]


  /**
   * Hook our parent's rebuild to cache our associated ports.
   * @param pools
   * @return a new pool-set, as generated by our parent
   */
  protected override def rebuild(pools: NeutrinoPools): Map[String, NeutrinoPool] = {
    ports = pools.service.settings.sourcePorts
    super.rebuild(pools)
  }


  /**
   * Helper function to determine if the address is a CNAME and the port specified matches
   * one of ours.
   *
   * @param address
   * @return
   */
  @inline def isCanonicalPool(address: VirtualAddress): Boolean =
    address match {
      case cname: CanonicalAddress if ports.contains(cname.port) => true
      case _ => false
    }

  /**
   * Rebuild the cached map on change of underlying source pools.
   *
   * This will generate one K/V per address/port/protocol tuple
   *
   * @param pools source-set of new replacement pools
   */
  def rebuild(pools: java.util.Iterator[VirtualPool]): java.util.Map[String, VirtualPool] =
  {
    // Helper method; determines if any of the addresses are mapped by our listener's sourcePort
    val relevant = pools filter { pool => pool.addresses find (isCanonicalPool) isDefined }

    // Split out the relevant (match on protocol/source-port)
    // Extract host-key
    val hosts = relevant flatMap { pool => pool.addresses collect {
        case addr: CanonicalAddress => (HostKey(addr), pool)
      }
    }

    // Build a java-map out of this
    val hostmap = new java.util.HashMap[String, VirtualPool]()
    hosts foreach { case (addr, pool) => hostmap.put(addr, pool) }
    hostmap
  }


  /**
   * This implements a simplified Java-style interface, which allows null-return value.
   *
   * @return a valid NeutrinoPool, or null if not resolved
   */
  @Nullable
  def resolve(request: NeutrinoRequest): String = HostKey(request) getOrElse null

}